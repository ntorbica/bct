#' @export
#'
#' @title Univariate locally weighted scatterplot smoothing (LOESS).
#' @param data.in Originally the output of InputAndProcessCSV. Within the pipeline,
#'   data.in is passed from BCT_brige.R, containing the data as prepared by the
#'   preceding functions.
#' @param info Information table generated by bct.infogen.
#' @param bn Batch labels as found in the sample names.
#' @param LOESS_SPAN Distance parameter defining the window of consideration for
#'   weighting of the response variable. Default = 0.75
#' @param LOESS_WARNING Logical; should a warning be produced by the call, if any occur?
#' @param normplot Logical; should normalization plots for each feature be produced and
#'   saved as .png?
#' @param pn Plot file name suffix \\(for proper batch naming\\)
#' @description Applies loess correction for intra-batch removal of technical variability.
#'   Original implementation by Stefan Zahnd for the LaunchAnalyzer toolkit.
#' @return Returns a numeric matrix containing the loess corrected peak intensity values.

bct.loess <- function(data.in, info, bn, LOESS_SPAN = 0.75, LOESS_WARNING = F, normplot = F, pn = NULL){

  ## Modified version of LaunchAnalyzer components, originally written by Stefan Zahnd.


# Description -------------------------------------------------------------

  ## Several variables and functions are altered such that the passing of arguments
  ## within BCT is not conflicting. The intent is to include a LOESS method to expand
  ## the normalization capabilities of the pipeline. Changes, such as naming, functionality,
  ## and variable assignment are described in comments at the site of replacement within the
  ## code.


# Input -------------------------------------------------------------------

 ## No global variables are assigned in the course of the BCT functions, therefore the
 ## variables are passed as arguments.

  # data.in:        Originally the output of InputAndProcessCSV(). Within the pipeline, data.in
  #                 is passed from BCT_brige.R, containing the data as prepared by the preceding
  #                 functions.

  # bn :            Batch naming as found in the sample names

  # LOESS_SPAN:     Distance parameter defining the window of consideration for weighting of the
  #                 response variable. Default = 0.75

  #                 Spans can also be passed as vector with optimized parameters, requiring
  #                 the same length/number of parameters as features.

  # LOESS_WARINING: Logical; should a warning be produced by loess(), if any occur?

  # normplot:       Logical; should normalization plots be produced?

  # QC.n:           Name of quality control group

  # pn:             plot file name suffix (for proper batch naming)



# Define required LaunchAnalyzer functions --------------------------------

  predict_values <- function(pred_df, QC_indices){
    QC_dataframe <- data.frame(Abundance = pred_df$RawAb[QC_indices], SeqNr = pred_df$SeqNr[QC_indices])

    loess_model <- loess(Abundance ~ SeqNr, data = QC_dataframe, span = LOESS_SPAN)
    loess_prediction <- as.numeric(predict(loess_model, newdata = data.frame(SeqNr = pred_df$SeqNr[which(pred_df$PredType == 'loess')])))

    cubic_model <- lm(Abundance ~ SeqNr + I(SeqNr^2) + I(SeqNr^3), data = QC_dataframe)
    cubic_prediction <- as.numeric(predict(cubic_model, newdata = data.frame(SeqNr = pred_df$SeqNr[which(pred_df$PredType == 'cubic')])))
    # Insert entries into pred_df (for returning):
    pred_df$PredValues[which(pred_df$PredType == 'cubic')] <- cubic_prediction
    pred_df$PredValues[which(pred_df$PredType == 'loess')] <- loess_prediction

    return(pred_df$PredValues)
  }


  ImportAndProcessCSV <- function(data.in, bn, summary_list){
    ## data.in replaces the unique file required by the function. Should
    ## be the exact same as an object produced by using read.table().

    ## bn are the batch namings found in the sample names. Required by seqmod()

    # Read in file:
    import_csv <- bct.tabwrap(data.in, c('character', 'data.frame'))
                  ## read.table() replaced by bct.tabwrap().

    mz_and_RT <- data.frame(import_csv[3:nrow(import_csv), c(1:5)]) # contains compound ID (i.e. m/z_rettime pasted), m/z, charge and retention time information
    for (i in 2:ncol(mz_and_RT)){mz_and_RT[,i] <- as.numeric(mz_and_RT[,i])}
    mz_and_RT[,1] <- as.character(mz_and_RT[,1])
    colnames(mz_and_RT) <- c('Compound ID', 'Neutral Mass','m/z', 'Charge', 'RetTime')
    sample_indices <- grep('_[0-9]{1,3}', import_csv[2,])
    sample_names <- as.character(import_csv[2,][sample_indices])


    ## The sample_order_df is altered to match the naming within BCT:
    #    Order -> SeqNr
    #    Group -> SCode
    #    Added Batch variable, used for seqmod(). This introduces a continuing injection sequence.

    b.id <- list()
    for (i in 1:length(bn)) {
      b.id[[i]] <- grep(bn[i], sample_names)
    }
    B <- sample_names
    for (i in 1:length(b.id)) {
      B[b.id[[i]]] <- bn[i]
    }
    sample_order_df <- data.frame(SampleNames = sample_names, SeqNr = bct.getseq(import_csv[2, sample_indices]), Batch = B)
    sample_order_df <- bct.seqmod(sample_order_df, bn)

    sample_order_df$SCode <- as.character(info$SCode)

    # Fill the group entries:
    current_group <- ''
    for (i in 1:nrow(sample_order_df)){
      if (sample_order_df$SCode[i] != '' & sample_order_df$SCode[i] != current_group){current_group <- sample_order_df$SCode[i]}
      else {sample_order_df$SCode[i] <- current_group}
    }
    # sample_order_df <- sample_order_df[order(sample_order_df$SeqNr),]
    sample_order_df$SCode <- as.factor(sample_order_df$SCode)
    colnames(import_csv) <- as.character(import_csv[2,])
    actual_data <- import_csv[3:nrow(import_csv), as.character(sample_order_df$SampleNames)]
    for (k in 1:ncol(actual_data)){actual_data[,k] <- as.numeric(actual_data[,k])}

    summary_list$Features <- nrow(actual_data)

    qc_grep <- grep('ref', as.character(levels(as.factor(sample_order_df$SCode))))
    if (length(qc_grep) > 1){
      stop('There are multiple QC groups in this experiment !')
    } else if (length(qc_grep) == 1){
      summary_list$QCSamples <- T
      summary_list$QCNames <- as.character(levels(as.factor(sample_order_df$SCode)))[grep('ref', as.character(levels(as.factor(sample_order_df$SCode))))]
    }

    ## LaunchAnalyzer functions will not be executed to the point of using
    ## the following variables.

    # Process some variables after reading in the data:
    #
    # CV_COLORS <- rainbow(length(levels(sample_order_df$SCode)))
    #
    # N_GROUPS <- length(levels(as.factor(sample_order_df$SCode)))

    RES <- list(Names = sample_names, SampleList = sample_order_df, Data = actual_data, Info = mz_and_RT)
    return(list(RES, summary_list))
  }


  create_prediction_map <- function(data.f, rawdata, with_warning = F){
    prediction_df <- data.frame(RawAb = unlist(rawdata), SCode = as.character(data.f$SampleList$SCode), SeqNr = as.numeric(factor(data.f$SampleList$SeqNr)),
                                PredType = character(length(rawdata)), PredValues = numeric(length(rawdata)), CorValues = numeric(length(rawdata)),
                                stringsAsFactors = F)
                     ## Here, the Order and Group variables are matched to the BCT names for ease of access.


    # declare NA samples:
    prediction_df$SCode[which(is.na(prediction_df$RawAb))] <- NA
    if (length(which(prediction_df$SCode == summary_list$QCNames)) < 6){
      prediction_df[1,] <- NA
      return(list(prediction_df = prediction_df[1,], warn_flag = F))
    }
    # a minimum of 6 QC samples is required
    inside_QC_sequence <- seq(prediction_df$SeqNr[min(which(prediction_df$SCode == summary_list$QCNames))], prediction_df$SeqNr[max(which(prediction_df$SCode == summary_list$QCNames))])
    prediction_df$PredType[which(prediction_df$SeqNr %in% inside_QC_sequence)] <- 'loess'
    QC_indices <- which(prediction_df$SCode == 'ref' & prediction_df$PredType == 'loess')

    # Remaining entries will be predicted using cubic spline interpolation:
    prediction_df$PredType[which(prediction_df$PredType != 'loess')] <- 'cubic'
    prediction_df$PredValues <- predict_values(prediction_df, QC_indices) # Creates predicted values


    # Calculate corrected values:
    prediction_df$CorValues <- prediction_df$RawAb - prediction_df$PredValues


    if (with_warning == F){
      prediction_list <- list(prediction_df = prediction_df, warn_flag = F)
    } else {
      prediction_list <- list(prediction_df = prediction_df, warn_flag = T)
    }
    return(prediction_list)
  }

  # applied LOESS_correction()  ---------------------------------------------

  loess_correction <- function(data.f, adjust.raw = F, LOESS_SPAN){
    ## as the MyCSV object is missing, it is instead passed as data.f,
    ## which is produced by ImportAndProcessCSV(). Also, the log.setting
    ## argument will be safety-locked by setting it == F in the function, as BCT_mod()
    ## already provides log transformation before the procedure intended to be
    ## preformed here.
    log.setting <- F

    # LOESS_WARNING <- F # Reset the LOESS_WARNING global variable

    bct.msg('Performing LOESS correction - this may take a few seconds...', side = 'none')

    approved <- F

    if (normplot){

      dir.create(paste('./LOESS_Plots', pn))
      setwd(paste('./LOESS_Plots', pn))

      for (i in 1:nrow(data.f$Data)){
        # prediction_list <- tryCatch(create_prediction_map(data.f, rawdata = as.numeric(data.f$Data[i,]), with_warning = F), error = function(e){print(e)},
        #                             warning = function(w){create_prediction_map(rawdata = as.numeric(data.f$Data[i,]), with_warning = T)})
        # The tryCatch statement will skip all entries that produce warnings in the call to loess() or lm(). Features with
        # missing data that do no longer fulfill the d.f. conditions will thus NOT be transformed !




        prediction_list <- create_prediction_map(data.f, rawdata = as.numeric(data.f$Data[i,]))

        prediction_df  <- prediction_list[[1]]


        if (length(which(is.na(prediction_df[1,]))) == 6) { next } # continue if there are too many missing data in the QC samples

        if (prediction_list[[2]] == T && LOESS_WARNING == F){
          bct.msg(c(cat('WARNING: Choosing correct parameters for the LOESS correction was difficult, probably due to extreme values in your data.\n'),
                    cat('Please ignore the Warnings Messages that will be produced by this function, but make sure to double check your results!')))
          LOESS_WARNING <- T
        }
        prediction_df <- prediction_list[[1]]

        # Adjust data if the adjust.raw flag is set:
        if (adjust.raw == T){
          adjust_factor <- mean(as.numeric(prediction_df$RawAb[which(prediction_df$SCode == summary_list$QCNames)]))
          prediction_df$CorValues <- prediction_df$CorValues + adjust_factor
        }

        plotn <- paste(round(data.f$Info$RetTime[i],2), paste(round(data.f$Info$'m/z'[i], 4), '.png', sep = ''), sep = '_')
        png(plotn,
            width = 15, height = 15, units = 'cm', res = 800)

        par(mfrow=c(1,2))
        # BEFORE PLOT
        plot(x = prediction_df$SeqNr, y = prediction_df$RawAb, type = 'b', pch = 16, cex = 0.7,
             main = paste('Before Correction\nRT: ',toString(round(data.f$Info$RetTime[i],2)), '   m/z: ', toString(round(data.f$Info$'m/z'[i], 4)), sep=''), xlab = 'Processing Order', ylab = 'Abundnace', xlim = c(min(prediction_df$SeqNr), max(prediction_df$SeqNr)),
             ylim = c(min(data.matrix(prediction_df[,c(1,5)]), na.rm=T), max(data.matrix(prediction_df[,c(1,5)]), na.rm=T)*1.1))
        points(x = prediction_df$SeqNr, y = prediction_df$PredValues, lwd = 2,
               col = 'red', type = 'l')
        points(x = prediction_df$SeqNr[which(prediction_df$SCode==summary_list$QCNames)], y = prediction_df$RawAb[which(prediction_df$SCode==summary_list$QCNames)],
               type = 'b', col = 'blue', lwd = 1.5, pch=16, cex=0.7)

        legend('topleft', legend = c('Raw Abundance', 'Fitted Values', 'QC Sample Abundance'), lwd = 2, cex = 0.7, col = c('black', 'red', 'blue'), bty = 'n')
        # AFTER PLOT
        plot(x = prediction_df$SeqNr, y = prediction_df$CorValues, type = 'b', pch = 16, cex = 0.7,
             main = paste('After Correction\n','Charge: ',toString(data.f$Info$Charge[i]), sep=''), xlab = 'Processing Order', ylab = 'Adjusted Abundance', xlim = c(min(prediction_df$SeqNr), max(prediction_df$SeqNr)),
             ylim = c(min(data.matrix(prediction_df[,6]), na.rm=T), max(data.matrix(prediction_df[,6]), na.rm=T)*1.1))
        points(x = prediction_df$SeqNr[which(prediction_df$SCode==summary_list$QCNames)], y = prediction_df$CorValues[which(prediction_df$SCode==summary_list$QCNames)],
               type = 'b', col = 'blue', lwd = 1.5, pch=16, cex=0.7)
        # abline(h = ifelse(log.setting == T, 1, ifelse(adjust.raw == F, 0, adjust_factor)))
        legend('topleft', legend = c('Adjusted Abundance', 'QC Adjusted Abundance'), lwd = 2, cex = 0.7, bty = 'n', col = c('black', 'blue'))
        print(noquote(paste('Span Parameter:', toString(LOESS_SPAN))))

        dev.off()

        # Reset samples with abundance = 0 as raw abundance:
        if (length(which(prediction_df$RawAb == 0)) > 0){
          prediction_df$CorValues[which(prediction_df$RawAb == 0)] <- 0
        }
        # Change data in the MyCSV$Data dataframe
        data.f$Data[i,] <- prediction_df$CorValues
      }

      setwd('..')

    } else {


      for (i in 1:nrow(data.f$Data)){

        prediction_list <- create_prediction_map(data.f, rawdata = as.numeric(data.f$Data[i,]))

        prediction_df  <- prediction_list[[1]]

        if (length(which(is.na(prediction_df[1,]))) == 6) { next } # continue if there are too many missing data in the QC samples

        if (prediction_list[[2]] == T && LOESS_WARNING == F){

          bct.msg(c(cat('WARNING: Choosing correct parameters for the LOESS correction was difficult, probably due to extreme values in your data.\n'),
                    cat('Please ignore the Warnings Messages that will be produced by this function, but make sure to double check your results!')))
          LOESS_WARNING <- T
        }


        # Adjust data if the adjust.raw flag is set:
        # if (adjust.raw == T){
        #   adjust_factor <- mean(as.numeric(prediction_df$RawAb[which(prediction_df$SCode == summary_list$QCNames)]))
        #   prediction_df$CorValues <- prediction_df$CorValues + adjust_factor
        # }

        # Reset samples with abundance = 0 as raw abundance:
        # if (length(which(prediction_df$RawAb == 0)) > 0){
        #   prediction_df$CorValues[which(prediction_df$RawAb == 0)] <- 0
        # }

        # Change data in the data.in (MyCSV$Data) dataframe
        data.f$Data[i,] <- prediction_df$CorValues
      }
    }

    data.f$Data <- t(bct.tabwrap(data.f$Data, c('numeric','matrix')))

    rownames(data.f$Data) <- data.f$Names
    colnames(data.f$Data) <- data.f$Info$`Compound ID`

    cat('Normalization successful!\n\n')
    return(data.f)
  }

# Execute ImportAndProcessCSV ---------------------------------------------


  summary_list <- list()
  ## Not all of the objects in summary_list are required, thus I let the
  ## functions just create the elements as present within them.


  data.f <- ImportAndProcessCSV(data.in, bn, summary_list)

  summary_list <- data.f[[2]]
  data.import <- data.f[[1]]


# Execute loess_correction() ----------------------------------------------

  data.o <- loess_correction(data.import, adjust.raw = F, LOESS_SPAN)

  return(data.o)
}

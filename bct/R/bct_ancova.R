#' @export
#'
#' @title Batch Effect Correction with Analysis of Covariance \(ANCOVA\)
#' @param peaks Input peak data table in pipeline format (samples are in rows, features
#'   are in columns).
#' @param info Information table generated by bct.infogen.
#' @param minQC Minimum number of quality control samples per batch. Any batch containing
#'   less than minQC quality control samples will be discarded for correction.
#' @param condition Missing data imputation option. Can be "" (none) to ignore NAs, 0 to
#'   impute NAs with 0, 1 to impute NAs with half of the limit of detection, 2 to impute
#'   NAs with the limit of detection, or "c" to automatically set a threshold for
#'   censored regression. Note that if set to "c", the method argument will be set to
#'   "tobit".
#' @param method Linear regression method option. Determines modelling approach applied
#'   to compute the ANCOVA corrected peak intensity values. Can be "lm" to perform linear
#'   model regression, "rlm" to perform robust linear regression, or "tobit" to perform
#'   censored regression by tobit. Note that if set to "tobit", the contidion argument
#'   will be set to "c".
#' @param QC Logical; should regression modelling be done with quality control samples
#'   (QC == T) or with the study samples?
#' @description Core element of the pipeline algorithm performing batch effect correction.
#'   Original implementation by R. Wehrens (Wehrens, R., Hageman, J. A., van Eeuwijk, F.,
#'   Kooke, R., Flood, P. J., Wijnker, E., â€¦ de Vos, R. C. H. (2016). Improved batch
#'   correction in untargeted MS-based metabolomics. Metabolomics, 12(5).
#'   https://doi.org/10.1007/s11306-016-1015-8).
#'   Uses an analysis of covariance framework containing three linear modelling approaches
#'   to estimate corrected values based on the applied regression.
#' @return Produces a numeric matrix containing the corrected peak intensities in the
#'   same format as the input.

bct.ancova <- function(peaks, info, minQC = 4, condition = c("", 0, 1, 2, "c"), method = c("lm", "rlm", "tobit"), QC = TRUE) {


    if (condition == "") {
        cat("You chose to ignore NA measurements.\n")
        impV <- NULL
    }
    if (condition == 0) {
        cat("You chose to impute NA measurements with 0.\n")
    }
    if (condition == 1) {
        cat("You chose to impute NA measurements with half the limit of detection.\n")
    }
    if (condition == 2) {
        cat("You chose to impute NA measurements with the limit of detection (lowest measurement).\n")
    }
    if (condition == "c") {
        cat("You chose to impute Values for a censored regression. Note that this will require 'tobit' as method.\n")
        method <- "tobit"
    }
    if (method == "tobit") {
        cat("You chose to perform censored regression. A threshold will be set at the limit of detection > 0")
        condition <- "c"
    }


    if (is.matrix(peaks) & is.data.frame(info)) {
        set.1 <- bct.tabwrap(peaks, c('numeric', 'matrix'))
        set.1.Y <- bct.tabwrap(info, c('factor', 'data.frame'))


        set.1.lod <- as.numeric(min(set.1[!is.na(set.1)]))
        if (condition == "0") {
            impV <- 0
        }
        if (condition == "1") {
            impV <- set.1.lod/2
        }
        if (condition == "2") {
            impV <- set.1.lod
        }
        if (condition == "c") {
            if (set.1.lod == 0) {
                impV <- set.1.lod + 0.01
            } else {
                impV <- set.1.lod - 0.01
            }
        }

        LC.ngenotypes <- nlevels(set.1.Y$SCode) - 1  # Get the data specific number of samples
        if (QC) {
            LC.nref <- sum(set.1.Y$SCode == "ref")  # Get the number of reference samples/QC measures
        }
        LC.nNA <- apply(set.1, 2, function(x) sum(is.na(x)))  # Get the number of NAs to account for per column


        # get the QC / sample indices
        refSamples <- list(Q = which(set.1.Y$SCode == "ref"), S = which(set.1.Y$SCode != "ref"))


        # with the complete set of possible procedures, we compare the user input and chose the appropriate one
        if (QC) {
            actual <- list(str = "Q", exp = condition, method = method, impV = impV)
        } else {
            actual <- list(str = "S", exp = condition, method = method, impV = impV)
        }

        bct.msg(cat("ANCOVA args:\n",
                    "\tcorrection model:\t", actual$method, "\n",
                    "\timputation value:\t", ifelse(is.null(actual$impV), 'none', actual$impV), "\n",
                    "\tstrategy:\t\t", actual$str),
                side = 'none')


        # Now we are set for batch correction.  ANCOVA type correction:

        D.A <- apply(set.1, 2,
                     doBC,
                     ref.idx = as.numeric(refSamples[[actual$str]]),
                     batch.idx = set.1.Y$Batch,
                     minBsamp = minQC,
                     seq.idx = as.numeric(set.1.Y$SeqNr),
                     method = actual$method,
                     imputeVal = actual$impV)
    }

    bct.msg('Correction successful!', side = 'none')
    return(D.A)
}

#' @export
#'
#' @title Produce formatted peak data table.
#' @param data.in Input list object containing the peak data table to format as well as
#'   an information table generated by bct.infogen.
#' @param long Logical; are the sample features in the rows (long = T). Transposes the
#'   input data to contain features in columns.
#' @param QC.n Name of quality control sample group.
#' @param backup.obj Logical; should a backup object containing the remaining parts of
#'   the input table after isolation of actual data be outputted?
#' @param p.id Column index of first sample column in input table (usually named 'Raw
#'   abundance')
#' @param bn Names of batch labels within sample names (usually second row in input
#'   table)
#' @param seqm Logical; should information on injection sequence extracted from sample
#'   names be modified to become one continuing sequence? Needed when injection sequence
#'   in the batches start at the same sequence index.
#' @description Function that takes the peak table input and produces the required format
#'   for passing in the bct correction algorithm. Also creates the required objects for
#'   reformatting to the input format.
#' @return Produces a list object with formatted peak table and backup object elements.

bct.format <- function(data.in, long = T, QC.n = 'QC', backup.obj = T, p.id = NULL, bn = NULL, seqm = T){

  ld <- length(data.in)

  if(ld != 2){
    warning("Number of list elements incorrect. Two elements (peak and information table) are needed.\n
            Any other number of elements may corrupt the formatting process.\n")
  }

  # Storage object
  if (is.list(data.in) | !is.data.frame(data.in)) {
    if (length(data.in) > 1) {

      if (object.size(data.in[[1]]) > object.size(data.in[[2]])) {
        D <- list()
        D[["P"]] <- data.in[[1]]
        D[["I"]] <- data.in[[2]]
      } else {
        D <- list()
        D[["P"]] <- data.in[[2]]
        D[["I"]] <- data.in[[1]]
      }

    } else {
      D <- list()
      D[["ALL"]] <- data.in[[1]]
    }

  } else {
    D <- list()
  }


  ###################################### given as filename/s
  # read into list
  if (is.character(data.in)) {


    # If given one input
    if (ld == 1) {
      D[["ALL"]] <- bct.tabwrap(tab.in = data.in, type.out = c("character", "matrix"))
    }

    # If given two inputs
    if (ld == 2) {
      # Index of peak file
      P.id <- grep("_raw.csv", data.in, value = F)

      D[["P"]] <- bct.tabwrap(data.in[P.id], c("character", "matrix"))
      D[["I"]] <- bct.tabwrap(data.in[-P.id], c("character", "matrix"))
    }
  }


  # execute formatting if object to format is list
  ld <- length(D)

  rownames(D[["P"]]) <- D[["P"]][, 1]
  rownames(D[["I"]]) <- D[["I"]][, 1]

  colnames(D[["P"]]) <- D[["P"]][2, ]

  # Below only applies to the peak table; border finding is skipped if p.id is given.
  # Identical as in original formatting.
  D[["P"]] <- t(D[["P"]])

  # Save the information part within the peak table in a separate object
  backup <- list()
  if(p.id > 1){
    backup <- t(D[["P"]])
    backup[3:nrow(backup), p.id:ncol(backup)] <- NA
    tmp <- backup[3:nrow(backup), ]
    backup[3:nrow(backup), ] <- tmp[order(tmp[, 1]), ]
    rownames(backup) <- backup[,1]

    D[["P"]] <- D[["P"]][-(1:(p.id - 1)), -c(1, 2)]
  }


# Peak Table --------------------------------------------------------------
  # Get sample names and feature names
  nms.s <- rownames(D[["P"]])
  nms.f <- colnames(D[["P"]])


  # order feature names by rt_m/z
  nms.ford <- nms.f[order(nms.f)]

  # use batch naming and seq to order by batch and injection sequence
  nms.sord <- nms.s[order(nms.s)]
  b.id <- list()
  for(i in bn){
    b.id[[i]] <- grep(i, nms.s)
  }

  # nms.sord <- c()
  # for(i in b.id){
  #   nms.sord <- c(nms.sord, nms.s.order[i])
  # }

  # Get injection sequence
  sq <- bct.getseq(nms.sord)

  # order the tables
  build.row <- NULL
  for(i in 1:nrow(D[["P"]])){
    sord.org <- which(rownames(D$P) == nms.sord[i])
    build.row <- rbind(build.row, D[["P"]][sord.org, ])
  }

  D[["P"]] <- build.row
  D[["P"]] <- D[["P"]][, order(colnames(D[["P"]]))]

  suppressWarnings(D[["P"]] <- bct.tabwrap(D[["P"]], c('numeric','matrix')))
  rownames(D[["P"]]) <- nms.sord
  colnames(D[["P"]]) <- nms.f


# Info Table --------------------------------------------------------------
  nms.s <- rownames(D[["I"]])

  # Rename QCs
  D[["I"]] <- bct.tabwrap(D[["I"]], c("character", "matrix"))
  qc.id <- which(D[["I"]] == QC.n)
  D[["I"]][qc.id] <- "ref"


  rownames(D[["I"]]) <- nms.s

  nms.sord <- nms.s[order(nms.s)]
  b.id <- list()
  for(i in bn){
    b.id[[i]] <- grep(i, nms.s)
  }


  build.row <- NULL
  for(i in 1:nrow(D[["I"]])){
    sord.org <- which(rownames(D[["I"]]) == nms.sord[i])
    build.row <- rbind(build.row, D[["I"]][sord.org, ])
  }
  D[["I"]] <- build.row


  D[["I"]] <- bct.tabwrap(D[["I"]], c('factor', 'data.frame'))
  colnames(D[["I"]]) <- c("Sample Names", "SCode", "Batch")
  rownames(D[["I"]]) <- D[["I"]][, "Sample Names"]
  D[["I"]][["SeqNr"]] <- sq

  if(seqm){
    D[["I"]] <- bct.seqmod(D[["I"]], bn)
  }

  rni <- as.character(unlist(D[["I"]]["Sample Names"]))
  rownames(D[["I"]]) <- rni
  D[["I"]] <- D[["I"]][,-1]

  return(list(D, backup))
}
